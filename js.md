# 原型与原型链
![原型](./images/原型.png)   
> prototype   
每个函数都有一个prototype属性，指向调用该构造函数而创建的实例的原型   

>原型   
可以理解为每一个js对象(null除外)在创建时候来关联的，用来“继承属性”的对象   

>\_\_proto\_\_   
用来表示实例与原型之间的关联。   
每一个js对象(null除外)都具有的，指向该对象原型的一个属性   

>consructor   
每个原型都有一个 constructor 属性指向关联的构造函数   

## 实例与原型
当读取实例的属性时，实例对象内找不到的情况下，会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直到最顶层为止   
之所以能够这样做，是因为原型也是一个对象，既然是一个对象，它就也是一个构造函数的实例   
![原型2](./images/原型2.png)   
到了这一步，那么，Object.prototype的原型是什么呢？   
null，没有对象，即此处不应该有值   
所以，查找原型的整个流程就是：   
![原型3](./images/原型3.png)   
图中的蓝色途径，就是原型链   

# 词法作用域与动态作用域
作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限   
js的作用域采用了词法作用域，即静态作用域，函数的作用域在函数定义的时候就已经定义了   
与之相对的动态作用域，是在函数调用的时候才决定的   
之间的区别可以根据这个例子来看：   
```javascript
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar(); // 1
// 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1
// 假设是动态作用域，执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2
```   

# 执行上下文栈
js代码的执行并非是一行一行顺序执行，而是一段一段执行，当执行一段代码时，会先进行一些准备工作，比如变量提升和函数提升，这个准备工作，即是执行上下文。   
当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个globalContext。   
当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。   
这个内容仅从定义上可能较难理解，可以看下几个例子：   
```js
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();

// 伪代码

// fun1()
// ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
// ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
// ECStack.push(<fun3> functionContext);

// fun3执行完毕
// ECStack.pop();

// fun2执行完毕
// ECStack.pop();

// fun1执行完毕
// ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```   
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
// ECStack.push(<checkscope> functionContext);
// ECStack.push(<f> functionContext);
// ECStack.pop();
// ECStack.pop();
```   
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
// ECStack.push(<checkscope> functionContext);
// ECStack.pop();
// ECStack.push(<f> functionContext);
// ECStack.pop();
```   

# 变量对象
变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明   
## 全局上下文
首先明确全局对象的定义：
>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性

即
1. 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象;客户端 JavaScript 中，全局对象有 window 属性指向自身：
   ```js
    var a = 1;
    console.log(window.a);

    this.window.b = 2;
    console.log(this.b);
   ```   
2. 全局对象是由 Object 构造函数实例化的一个对象
3. 预定义了很多函数与属性
4. 作为全局变量的宿主

所以说，全局上下文的变量对象就是全局对象
## 函数上下文
在函数上下文中，用活动对象(AO)来表示变量对象   
活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象   

执行上下文的代码会分为分析和执行两个部分来进行，即：
## 进入执行上下文
代码未执行时，变量对象会包括：
1. 函数的所有形参 (如果是函数上下文)
2. 变量声明（注意未声明的变量不会存在AO中）
3. 函数声明（注意const fun = function(){}这种不是函数声明）
## 代码执行
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值   

一个需要注意的题目：   
```js
console.log(foo);// 会打印函数，而不是 undefined 

function foo(){
    console.log("foo");
}

var foo = 1;
// 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
```   

# 作用域链
当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链   
函数作用域链可以通过函数创建和函数激活两个过程来进行讲解：   
## 函数创建
函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链（因为只有它的父变量对象）   
## 函数激活
当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。至此，作用域链创建完毕   

# this指向
1. 如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，而是undefined   
2. 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象   
3. 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象   
要注意的是，this永远指向的是最后调用它的对象：   
```js
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //12
        }
    }
}
o.b.fn();
```   
```js
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
```   

# 闭包
闭包是指那些能够访问自由变量的函数   
>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量   

而从实践角度上而言，满足以下两点的才是闭包：   
* 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
* 在代码中引用了自由变量   

>闭包的形成机制   
涉及到上面的作用域链：当我们调用一个闭包函数时，因为函数执行时，其上下文有个Scope属性，该属性作为一个作用域链包含有该函数被定义时所有外层的变量对象的引用，所以定义了闭包的函数虽然销毁了，但是其变量对象依然被绑定在闭包函数上，保留在内存中

# 垃圾回收
js垃圾回收机制的原因：   
由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。   
垃圾回收的两种机制：   
* 引用计数   
   不太常见，跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。   
   但是它有一个漏洞，就是循环引用：   
   ```js
    function problem() {
        var objA = new Object();
        var objB = new Object();

        objA.someOtherObject = objB;
        objB.anotherObject = objA;
    }
   ```   
   在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。   
* 标记清除   
   最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。   

不过虽然有垃圾回收机制，还是有一些不当操作会引起内存泄漏：   
* 意外的全局变量引起的内存泄露（运行时的全局变量不会被回收）
* 闭包引起的内存泄露
* 没有清楚的dom元素引用
* 被遗忘的定时器

# 内存管理
![内存空间](./images/内存空间.png)   
JS内存空间分为栈(stack)，堆(heap)，池(一般也会归类为栈中)，其中栈存放变量，堆存放复杂对象，池存放常量。   
JS中的基本数据类型（Number,String,Boolean,null,undefined,Symbol），这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。
>闭包中的变量并不保存在栈内存中，而是保存在堆内存中。考虑到上面的执行上下文，闭包函数的创建上下文销毁之后，所引用的自由变量仍然保留在存储在堆中的[[scope]]作用域链对象属性里   

引用数据类型(Object)的值则都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。   

# 深浅拷贝
区别引用赋值与深浅拷贝，引用赋值是将数组或对象的堆内地址赋值给变量，导致修改的是同一地址的数据。而深浅拷贝是拷贝层级问题。   
## 数组的浅拷贝
我们可以利用数组的一些方法，如   
slice、concat来进行数组的拷贝：   
